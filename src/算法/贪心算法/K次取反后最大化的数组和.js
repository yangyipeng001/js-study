/**
 * K次取反后最大化的数组和
 * 
 * 题意：
 *  给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）
 *  以这种方式修改数组后，返回数组可能的最大和。
 * 
 * 示例 1：
 *  输入：A = [4,2,3], K = 1
 *  输出：5
 *  解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。
 * 
 * 示例 2：
 *  输入：A = [3,-1,0,2], K = 3
 *  输出：6
 *  解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。
 * 
 * 示例 3：
 *  输入：A = [2,-3,-1,5,-4], K = 2
 *  输出：13
 *  解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
 * 
 * 提示：
 *  1 <= A.length <= 10000
 *  1 <= K <= 10000
 *  -100 <= A[i] <= 100
 * 
 * 
 * 思路：
 *  本题思路其实比较好想了，如何可以让数组和最大呢？
 *  贪心的思路，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。
 *  局部最优可以推出全局最优。
 *  那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。
 *  那么又是一个贪心：局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。
 *  虽然这道题目大家做的时候，可能都不会去想什么贪心算法，一鼓作气，就AC了。
 *  我这里其实是为了给大家展现出来 经常被大家忽略的贪心思路，这么一道简单题，就用了两次贪心！
 *  那么本题的解题步骤为：
 *      第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
 *      第二步：从前向后遍历，遇到负数将其变为正数，同时K--
 *      第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
 *      第四步：求和
 * 
 * 
 * 总结：
 *  贪心的题目如果简单起来，会让人简单到开始怀疑：本来不就应该这么做么？这也算是算法？我认为这不是贪心？
 *  本题其实很简单，不会贪心算法的同学都可以做出来，但是我还是全程用贪心的思路来讲解。
 *  因为贪心的思考方式一定要有！
 *  如果没有贪心的思考方式（局部最优，全局最优），很容易陷入贪心简单题凭感觉做，贪心难题直接不会做，其实这样就锻炼不了贪心的思考方式了。
 */
const largestSumAfterKNegations = function(nums, k) {
    // 将数组按照绝对值大小从大到小排序
    nums.sort((a, b) => {
        return Math.abs(b) - Math.abs(a)
    })

    // 从前向后遍历，遇到负数将其变为正数，同时K--
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] < 0 && k > 0) {
            nums[i] *= -1
            k--
        }
    }

    // 如果K还大于0，那么反复转变数值最小的元素，将K用完 (因为可以总是反转同一个索引的值)
    if (k > 0 && k % 2 === 1) {
        nums[nums.length - 1] *= -1 
    }
    k = 0

    // 求和
    return nums.reduce((a, b) => {
        return a + b
    })
};


// 测试
// 5
const A1 = [4,2,3,]
const K1 = 1
// 6
const A2 = [3,-1,0,2]
const K2 = 3
// 13
const A3 = [2,-3,-1,5,-4]
const K3 = 2

console.log(largestSumAfterKNegations(A1, K1))
console.log(largestSumAfterKNegations(A2, K2))
console.log(largestSumAfterKNegations(A3, K3))