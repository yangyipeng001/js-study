/**
 * 最大子序和
 * 
 * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
 * 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
 */

/**
 * 暴力解法
 * 
 * 暴力解法的思路，第一层for 就是设置起始位置，第二层for循环遍历数组寻找最大值
 * 
 * 复杂度
 *  时间复杂度：O(n^2)
 *  空间复杂度：O(1)
 */

/**
 * 动态规划 - 放在动态规划中具体讲解
 * 
 * 复杂度：
 *  时间复杂度：O(n)
 *  空间复杂度：O(n）
 */


/**
 * 贪心解法
 * 
 * 贪心贪的是哪里呢？
 *  如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！
 *  局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
 *  全局最优：选取最大“连续和”
 * 
 * 局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。
 *  从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。
 * 
 * 这相当于是暴力解法中的不断调整最大子序和区间的起始位置。
 * 那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？
 * 区间的终止位置，其实就是如果count取到最大值了，及时记录下来了。
 * 这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）。
 * 
 * 总结：
 *  当然题目没有说如果数组为空，应该返回什么，所以数组为空的话返回啥都可以了。
 *  不少同学认为 如果输入用例都是-1，或者 都是负数，这个贪心算法跑出来的结果是0， 这是又一次证明脑洞模拟不靠谱的经典案例，建议大家把代码运行一下试一试，就知道了，也会理解 为什么 result 要初始化为最小负数了。
 * 
 * 
 * 复杂度：
 *  时间复杂度：O(n)
 *  空间复杂度：O(1)
 */

const maxSubArray = function(nums) {
    let result = -Infinity
    let count = 0

    for (let i = 0; i < nums.length; i++) {
        count += nums[i]

        // 取区间累计的最大值（相当于不断确定最大子序终止位置）
        if (count > result) {
            result = count
        }

        // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        if (count <= 0) {
            count = 0
        }
    }

    return result
};


// 测试
const arr = [-2,1,-3,4,-1,2,1,-5,4]
console.log(maxSubArray(arr))
